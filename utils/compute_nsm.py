import numpy as np
from utils.new_search_fixed import search_nearest_point, sign
def compute_nsm( B:np.array)->np.float32:
    #n: dimension of the generator matrix B
    n = B.shape[0]
    nsm = 0.0   
    
    #numbers of points to be used for calculating nsm
    num_samples=100000

    for i in range(num_samples):
        #generate random point
        r = np.random.rand(n)
        #search the nearest point to r in the lattice generated by B
        v = search_nearest_point(n,B,r)
        v=v[1:]

        #calculate the distance between r and v
        dist = np.linalg.norm(r-v@B)
        #update the nsm
        nsm += dist**2
    
    A=B@(B.T)
    V=np.sqrt(np.linalg.det(A))
    #normalize the nsm
    nsm= nsm* (1/n) * np.power(V,-2/n)
    nsm /= num_samples
    print(f"the nsm calcualted is {nsm}")
    return nsm


def test_compyte_nsm():
    n_list = [i for i in range (2,10)]
    for n in n_list:
        B = np.eye(n)
        nsm = compute_nsm(B)
        #the theoritical value of nsm for cubic lattice is 1/12
        print(f"the error between calculate nsm and 1/12 in dimesiton {n} is {np.abs(nsm-1/12)}")
        assert np.abs(nsm-1/12)<1e-3

if __name__ == "__main__":
    test_compyte_nsm( )
    print("test passed on cubic lattice")