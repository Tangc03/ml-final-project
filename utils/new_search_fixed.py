import numpy as np

def sign(x):
    if x<=0:
        return -1
    else:
        return 1
def search_nearest_point(n:int,G:np.array,r:np.array)->np.array:
    #find the nearest point v to given lattice generated by lower_triangular_matrix G of n-dimension
    #n: dimension of the lattice
    #G: lower triangular matrix of n-dimension
    #r: point to be searched
    #return: nearest point to v in the lattice
    u_hat=np.zeros(n+1)
    
    c=float ('inf') # C = \infty
    
    d=[n for _ in range(n+1)] #d_j=n for j=1,2,...,n
    
    lamda=[0 for _ in range (n+2)]
    lamda[n+1]=0 #lamda_{n+1}=0

    delta=[0 for _ in range(n+1)]

    u=np.zeros(n+1) #原文中没有，照github的实现猜的
    
    p=[0 for _ in range(n+1)]
    
    new_G=np.zeros((n+1,n+1))
    new_r=np.zeros(n+1)

    for k in range (n):
        new_r[k+1]=r[k]
        for j in range (n):
            new_G[k+1][j+1]=G[k][j]

    F=np.zeros((n+1,n+1))
    F[n]=new_r #F_{n,j}=r_j for j=1,2,...,n
    loop_flag=True

    i=n+1
    while (True):
        while (loop_flag):
            if(i != 1):
                i=i-1
                #print(f'd[i]={d[i-1]}')
                #print(f'i={i}')

                for j in range(d[i],i,-1): #j=d_i,d_i-1,...,i+1
                    F[j-1][i]=F[j][i]-u[j]*new_G[j][i]
                    #F_{j-1,i}=F_{j,i}-u_j*G_{j,i}

                p[i]=F[i][i]/new_G[i][i]
                #p_i=F_{i,i}/G_{i,i}

                u[i]=np.floor(p[i]+0.5)
                #u_i=round(p_i)

                y=(p[i]-u[i])*new_G[i][i]
                # print(f"y is {y}")
                #y=(p_i-u_i)*G_{i,i}

                delta[i]=sign(y)
                #\delta_i=sign(y)
                # print(f'i={i}')
                lamda[i]=lamda[i+1]+y*y
                #\lambda_{i}=\lambda_{i+1}+y^2
                #print(f"update lamda[{i-1}]")
            else:
                u_hat=u.copy()
                c=lamda[1]
            loop_flag=(lamda[i]<c)

        m=i
        while(not loop_flag):
            
            if (i==n):
                print(f'exit when i={i},lamda[i]={lamda[i]}')
                return u_hat
            else:
                i=i+1
            
                u[i]=u[i]+delta[i]
            #u_i=u_i+\delta_i

                delta[i]=-delta[i]-sign(delta[i])
            #\delta_i=-\delta_i-sign(\delta_i)

                y=(p[i]-u[i])*new_G[i][i]
            #y=(p_i-u_i)*G_{i,i}
                lamda[i]=lamda[i+1]+y*y
            loop_flag=(lamda[i]<c)

        for j in range (m,i-2):#for j=m,m+1,...,i-1
            d[j]=i
            #d_j=i for j=m,m+1,...,i-1
        for j in range (m-1,0,-1):#for j=m-1,m-2,...,1
            if (d[j]<i):
                d[j]=i
            else:
                break

if __name__ == '__main__':
    n=3
    G=np.array([[1,0,0],[0,1,0],[0,0,1]])
    print(G)
    r=np.array([0.5,0.0,0.0])
    print(search_nearest_point(n,G,r))